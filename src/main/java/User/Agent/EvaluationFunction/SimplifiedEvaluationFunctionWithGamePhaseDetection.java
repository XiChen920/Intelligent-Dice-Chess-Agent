package User.Agent.EvaluationFunction;

import Model.Model;
import Model.BoardState;
import Model.PieceInterface;

public class SimplifiedEvaluationFunctionWithGamePhaseDetection implements EvaluationFunction{

    @Override
    public boolean getMaximizingPlayer() {
        return false;
    }

    /**
     * @return the max value that can be generated by evaluation function
     */
    @Override
    public double getMaxEvaluation() {
        return 10e4;
    }

    /**
     * @return the min value that can be generated by evaluation function
     */
    @Override
    public double getMinEvaluation() {
        return -10e4;
    }

    /**
     *  This evaluation function refer to how to score a board state in Minimax
     *  Minimax usually associates the white side with the max-player
     *  and black with the min-player and always evaluates from the white point of view
     *  Higher the score is, better the board state is for white side
     *
     * An evaluation function for chess might take the form：
     * c1 * material + c2 * mobility + c3 * king safety + c4 * center control + c5 * pawn structure + c6 * king tropism + ...
     *
     * But to simplify, Material and piece-square tables alone are enough for a program to play a semi-decent game of chess
     * -Simplified Evaluation Function by Tomasz Michniewski on the Polish chess programming discussion list (progszach)
     *
     * The evaluation function we use here, consider the material, piece-square table, game phases
     *
     * Ref：
     * Ulysse Carion. Creating a chess-playing computer program. 2013
     *
     * Dan Heisman. Elements of Positional Evaluation: How the Pieces Get
     * Their Power. SCB Distributors, 2010.
     *
     */
    @Override
    public double evaluation(Model model){
        double boardScore = 0;//total board score

        BoardState currentBoardState = model.getBoardState();
        PieceInterface[][] board = currentBoardState.getPieceSet();
        byte gamePhase = getGamePhase(board);

        byte i, j;
        for(i=0;i< board.length;i++) {
            for (j = 0; j < board[i].length; j++) {

                if (board[i][j] != null) {

                    boolean player = board[i][j].getPlayer();
                    byte pieceType = board[i][j].getTypeOfPiece();

                    //material evaluation
                    boardScore += materialEvaluation(player, pieceType, gamePhase);

                    //Piece-square tables evaluation
                    boardScore += pieceSquareTableEvaluation(player, pieceType, i,j,gamePhase);

                }
            }
        }
        return boardScore;
    }

    /**
     * Detect which game phase the board is in
     * @return 0 for opening, 1 for middlegame, 2 for endgame
     *
     *
     * The division of game phased: Opening, MiddleGame, EndGame
     * Lichess (https://lichess.org/)uses this definition:
     *
     *
     * Opening starts on move 1.
     *
     * Mid-game is less obvious. The long-and-short of the current heuristics are that the mid-game occurs when either:
     * - 2 sets of minor or major pieces have been taken off the board.(there are 10 or fewer major or minors)
     *   (This is mainly useful for when the position is quite open)
     * - the back rank is sparse
     * - OR the white and black pieces are sufficiently mixed on the board.
     *
     * End-game is  when there are less than 7 minor and major pieces on the board the end-game has begun
     * (so, perhaps 2 rooks and a bishop Vs 2 bishops and a knight).
     *  or no queen piece exists
     *
     *
     */
    public byte getGamePhase(PieceInterface[][] board){

        int queenNum = 0;
        int MajMinNum = 0;//only including major pieces and minor pieces
        //major pieces:queen 5 & rook 2
        //minor pieces:bishop 4 & knight 3
        int emptyBackRank = 0; //how much empty space in the back rank

        for(byte i=0;i< board.length;i++) {
            for (byte j = 0; j < board[i].length; j++) {
                if (board[i][j] != null) {
                    byte pieceType = board[i][j].getTypeOfPiece();
                    if(pieceType == 5){
                        queenNum++;
                        MajMinNum++;
                    }
                    if(pieceType == 2||pieceType == 3 ||pieceType== 4 ){
                        MajMinNum++;
                    }
                }
                else{
                    if(i==0||i==1||i==6||i==7){
                        emptyBackRank ++;
                    }
                }
            }
        }
        //endgame:
        // -less than 7 minor and major pieces on the board or
        // -no queen
        if(queenNum ==0 || MajMinNum<7){
            return 2;
        }
        //middle game:
        //-there are 10 or fewer major or minors
        //-the back rank is sparse , more than 12 piece leave starting safe zone
        else if((MajMinNum<=10 )||emptyBackRank >= 12){
            return 1;
        }
        //opening
        return 0;
    }


    /**
     * calculate the material score for a single piece
     * the score is positive if the piece is white, negative if black
     *
     * material
     * is a term determined by the sum of piece values of each side.
     * The material value is the most influential part of the evaluation.
     * Usually it is the sum of a constant value for each piece present
     * https://www.chessprogramming.org/Material
     *
     *
     * @param player white-false, black-true
     * @param pieceType the piece type
     * @return the material score of this piece
     *
     * ref：
     * Sacha Droste and Johannes F  ̈urnkranz. Learning the piece values
     * for three chess variants. ICGA Journal, 31(4):209–233, 2008
     *
     */
    public double materialEvaluation(boolean player, byte pieceType, byte gamePhase){

        double pawnValue = 100;
        double rookValue = 500;
        double knightValue = 320;
        double bishopValue = 330;
        double queenValue = 1000;
        double kingValue = 10000;
        int sign;



        if(gamePhase == 0){//opening phase, the knight weights more
            knightValue = 360;

        }
        //when there's less chess, rook become heavier
        else if(gamePhase == 1){
            rookValue = 530;
        }
        else if(gamePhase == 2){
            rookValue = 560;
            pawnValue = 200;
        }

        if(player){//black
            sign = -1;
        }
        else{//white
            sign = 1;
        }

        switch (pieceType) {
            case 1: return pawnValue * sign;
            case 2: return rookValue * sign;
            case 3: return knightValue * sign;
            case 4: return bishopValue * sign;
            case 5: return queenValue * sign;
            case 6: return kingValue * sign;
            default: return 0;
        }
    }

    /**
     * Piece Square Table
     * is a simple way to assign values to specific pieces on specific squares.
     * A table is created for each piece of each color, and values assigned to each square.
     * The values in the tables are bonuses/penalties for the location of each piece on each space.
     * Basic tables can be constructed from principles of development, center control, king safety, etc.
     *
     *
     * @param player black-true, white-false
     * @param pieceType type of piece
     * @param xPos x coordinate of the piece
     * @param yPos y coordinate of the piece
     * @return the score of this piece in the piece square table accordingly
     *         - !!note: use the negative value from table of black pieces instead of just taking it directly
     *
     * ref：
     * Sacha Droste and Johannes F  ̈urnkranz. Learning of piece values
     * for chess variants. Technical report, Tech. Rep. TUD–KE–2008-07,
     * Knowledge Engineering Group, TU Darmstadt, 2008.
     */
    public double pieceSquareTableEvaluation(boolean player, byte pieceType, int xPos, int yPos, byte gamePhase){

        // For pawns, we encourage the pawns to advance.
        // Additionally, we try to discourage the engine from leaving central pawns unmoved.
        double[][] blackPawnTable = {
                { 0,  0,  0,  0,  0,  0,  0,  0},
                {50, 50, 50, 50, 50, 50, 50, 50},
                {10, 10, 20, 30, 30, 20, 10, 10},
                { 5,  5, 10, 25, 25, 10,  5,  5},
                { 0,  0,  0, 20, 20,  0,  0,  0},
                { 5, -5,-10,  0,  0,-10, -5,  5},
                { 5, 10, 10,-20,-20, 10, 10,  5},
                { 0,  0,  0,  0,  0,  0,  0,  0}
        };
        double[][] whitePawnTable = {
                { 0,  0,  0,  0,  0,  0,  0,  0},
                { 5, 10, 10,-20,-20, 10, 10,  5},
                { 5, -5,-10,  0,  0,-10, -5,  5},
                { 0,  0,  0, 20, 20,  0,  0,  0},
                { 5,  5, 10, 25, 25, 10,  5,  5},
                {10, 10, 20, 30, 30, 20, 10, 10},
                {50, 50, 50, 50, 50, 50, 50, 50},
                { 0,  0,  0,  0,  0,  0,  0,  0},
        };
        //Rook is encouraged to centralize, occupy the 7th/2nd rank and avoid a h columns (in order not to defend pawn b3 from a3).
        // So generally this is Gerbil like
        double[][] blackRookTable = {
                { 0,  0,  0,  0,  0,  0,  0,  0},
                { 5, 10, 10, 10, 10, 10, 10,  5},
                {-5,  0,  0,  0,  0,  0,  0, -5},
                {-5,  0,  0,  0,  0,  0,  0, -5},
                {-5,  0,  0,  0,  0,  0,  0, -5},
                {-5,  0,  0,  0,  0,  0,  0, -5},
                {-5,  0,  0,  0,  0,  0,  0, -5},
                { 0,  0,  0,  5,  5,  0,  0,  0}
        };
        double[][] whiteRookTable = {
                { 0,  0,  0,  5,  5,  0,  0,  0},
                {-5,  0,  0,  0,  0,  0,  0, -5},
                {-5,  0,  0,  0,  0,  0,  0, -5},
                {-5,  0,  0,  0,  0,  0,  0, -5},
                {-5,  0,  0,  0,  0,  0,  0, -5},
                {-5,  0,  0,  0,  0,  0,  0, -5},
                { 5, 10, 10, 10, 10, 10, 10,  5},
                { 0,  0,  0,  0,  0,  0,  0,  0},
        };
        //With knights,we simply encourage them to go to the center.
        // Standing on the edge is a bad idea.
        // Standing in the corner is a terrible idea.
        // And knights move slowly.
        double[][] blackKnightTable = {
                {-50,-40,-30,-30,-30,-30,-40,-50},
                {-40,-20,  0,  0,  0,  0,-20,-40},
                {-30,  0, 10, 15, 15, 10,  0,-30},
                {-30,  5, 15, 20, 20, 15,  5,-30},
                {-30,  0, 15, 20, 20, 15,  0,-30},
                {-30,  5, 10, 15, 15, 10,  5,-30},
                {-40,-20,  0,  5,  5,  0,-20,-40},
                {-50,-40,-30,-30,-30,-30,-40,-50},
        };
        double[][] whiteKnightTable = {
                {-50,-40,-30,-30,-30,-30,-40,-50},
                {-40,-20,  0,  5,  5,  0,-20,-40},
                {-30,  5, 10, 15, 15, 10,  5,-30},
                {-30,  0, 15, 20, 20, 15,  0,-30},
                {-30,  5, 15, 20, 20, 15,  5,-30},
                {-30,  0, 10, 15, 15, 10,  0,-30},
                {-40,-20,  0,  0,  0,  0,-20,-40},
                {-50,-40,-30,-30,-30,-30,-40,-50}
        };
        //We avoid corners and borders.
        // Additionally, we prefer squares like b3, c4, b5, d3 and the central ones.
        // Moreover, It's not recommended to exchange black bishop at d3 (or c3) for white knight at e4,
        // so squares at c3 (f3) have value of 10. As a result black bishop at d3 (c3) is worth (330+10) and white knight at e4 is worth (320+20).
        // So the choice of whether to exchange or not should depend on other issues.
        // On the contrary black bishop at e4 (330+10) would be captured by white knight from f6 (320+10).
        // black bishop at g5 (330+5) won't capture white knight at f6 (320+10).
        double[][] blackBishopTable = {
                {-20,-10,-10,-10,-10,-10,-10,-20},
                {-10,  0,  0,  0,  0,  0,  0,-10},
                {-10,  0,  5, 10, 10,  5,  0,-10},
                {-10,  5,  5, 10, 10,  5,  5,-10},
                {-10,  0, 10, 10, 10, 10,  0,-10},
                {-10, 10, 10, 10, 10, 10, 10,-10},
                {-10,  5,  0,  0,  0,  0,  5,-10},
                {-20,-10,-10,-10,-10,-10,-10,-20},
        };
        double[][] whiteBishopTable = {
                {-20,-10,-10,-10,-10,-10,-10,-20},
                {-10,  5,  0,  0,  0,  0,  5,-10},
                {-10, 10, 10, 10, 10, 10, 10,-10},
                {-10,  0, 10, 10, 10, 10,  0,-10},
                {-10,  5,  5, 10, 10,  5,  5,-10},
                {-10,  0,  5, 10, 10,  5,  0,-10},
                {-10,  0,  0,  0,  0,  0,  0,-10},
                {-20,-10,-10,-10,-10,-10,-10,-20}
        };
        // Generally with queen, it is marked places where not good to have a queen.
        // Additionally, It is slightly marked central squares to keep the queen in the centre
        // and b3, c2 squares (Paweł's suggestion). The rest should be done by tactics.
        double[][] blackQueenTable = {
                {-20,-10,-10, -5, -5,-10,-10,-20},
                {-10,  0,  0,  0,  0,  0,  0,-10},
                {-10,  0,  5,  5,  5,  5,  0,-10},
                { -5,  0,  5,  5,  5,  5,  0, -5},
                {  0,  0,  5,  5,  5,  5,  0, -5},
                {-10,  5,  5,  5,  5,  5,  0,-10},
                {-10,  0,  5,  0,  0,  0,  0,-10},
                {-20,-10,-10, -5, -5,-10,-10,-20}
        };
        double[][] whiteQueenTable = {
                {-20,-10,-10, -5, -5,-10,-10,-20},
                {-10,  0,  5,  0,  0,  0,  0,-10},
                {-10,  5,  5,  5,  5,  5,  0,-10},
                {  0,  0,  5,  5,  5,  5,  0, -5},
                { -5,  0,  5,  5,  5,  5,  0, -5},
                {-10,  0,  5,  5,  5,  5,  0,-10},
                {-10,  0,  0,  0,  0,  0,  0,-10},
                {-20,-10,-10, -5, -5,-10,-10,-20}

        };
        //This is to make the king stand behind the pawn shelter
        double[][] blackKingTable = {//middle game value
                {-30,-40,-40,-50,-50,-40,-40,-30},
                {-30,-40,-40,-50,-50,-40,-40,-30},
                {-30,-40,-40,-50,-50,-40,-40,-30},
                {-30,-40,-40,-50,-50,-40,-40,-30},
                {-20,-30,-30,-40,-40,-30,-30,-20},
                {-10,-20,-20,-20,-20,-20,-20,-10},
                { 20, 20,  0,  0,  0,  0, 20, 20},
                { 20, 30, 10,  0,  0, 10, 30, 20}
        };
        double[][] whiteKingTable = {
                { 20, 30, 10,  0,  0, 10, 30, 20},
                { 20, 20,  0,  0,  0,  0, 20, 20},
                {-10,-20,-20,-20,-20,-20,-20,-10},
                {-20,-30,-30,-40,-40,-30,-30,-20},
                {-30,-40,-40,-50,-50,-40,-40,-30},
                {-30,-40,-40,-50,-50,-40,-40,-30},
                {-30,-40,-40,-50,-50,-40,-40,-30},
                {-30,-40,-40,-50,-50,-40,-40,-30},
        };
        if(gamePhase == 2) {//end game value for king, king is encouraged to attack
            blackKingTable = new double[][]{
                    {-50, -40, -30, -20, -20, -30, -40, -50},
                    {-30, -20, -10, 0, 0, -10, -20, -30},
                    {-30, -10, 20, 30, 30, 20, -10, -30},
                    {-30, -10, 30, 40, 40, 30, -10, -30},
                    {-30, -10, 30, 40, 40, 30, -10, -30},
                    {-30, -10, 20, 30, 30, 20, -10, -30},
                    {-30, -30, 0, 0, 0, 0, -30, -30},
                    {-50, -30, -30, -30, -30, -30, -30, -50}
            };
            whiteKingTable = new double[][]{
                    {-50, -30, -30, -30, -30, -30, -30, -50},
                    {-30, -30, 0, 0, 0, 0, -30, -30},
                    {-30, -10, 20, 30, 30, 20, -10, -30},
                    {-30, -10, 30, 40, 40, 30, -10, -30},
                    {-30, -10, 30, 40, 40, 30, -10, -30},
                    {-30, -10, 20, 30, 30, 20, -10, -30},
                    {-30, -20, -10, 0, 0, -10, -20, -30},
                    {-50, -40, -30, -20, -20, -30, -40, -50},
            };
        }



        if (player){//black
            switch (pieceType) {
                case 1: return blackPawnTable[xPos][yPos] * -1;
                case 2: return blackRookTable[xPos][yPos] * -1;
                case 3: return blackKnightTable[xPos][yPos] * -1;
                case 4: return blackBishopTable[xPos][yPos] * -1;
                case 5: return blackQueenTable[xPos][yPos] * -1;
                case 6: return blackKingTable[xPos][yPos] * -1;
                default: return 0;
            }
        }
        else{//white
            switch (pieceType) {
                case 1: return whitePawnTable[xPos][yPos];
                case 2: return whiteRookTable[xPos][yPos];
                case 3: return whiteKnightTable[xPos][yPos];
                case 4: return whiteBishopTable[xPos][yPos];
                case 5: return whiteQueenTable[xPos][yPos];
                case 6: return whiteKingTable[xPos][yPos];
                default: return 0;
            }
        }
    }

    @Override
    public Object clone() {
        return new SimplifiedEvaluationFunctionWithGamePhaseDetection();
    }
}
